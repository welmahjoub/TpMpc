# Chargement des librairies nÃ©cÃ©ssaires
library(stats)
library(expsmooth)

source("./fonctions_tp1_st.R")

# Quelques rappels de manipulation de donnÃ©es avec R
# Si vous avez un vecteur v qui contient des valeurs, 
#   length(v) permet de connaitre sa longueur
#   v[ i ] permet de rÃ©cuperer la i-Ã¨me valeur de ce vecteur, si elle existe
#   v[ i:j ] permet de rÃ©cupÃ©rer un vecteur contenant toutes les valeurs de v d'indice entre i et j 
#   Attention Ã  mettre des parenthÃ¨ses avant ou aprÃ¨s les ":" si besoin
#   exemple : v[ i:(i+1) ] pour rÃ©cupÃ©rer les i et i+1 Ã¨mes valeurs (v[i:i+1] ne fait pas pareil, vous pourrez essayer)
# Si vous avez deux vecteurs u et v, 
#    - u + v calcule la somme deux Ã  deux des Ã©lÃ©ments de u et de v
#    - u - v calcule la diffÃ©rence deux Ã  deux des Ã©lÃ©ments de u et de v
# exemple: 
u = c(4,5,2)
v = c(3,4,8)
u+v
u-v

# Pour tracer un graphe : 
# - plot(y) --> trace la courbe avec le vecteur y en ordonnÃ©e, les abscisses Ã©tant par dÃ©faut 1,2,3,..., length(y)
# - plot(x,y) --> trace la courbe avec le vecteur x en abscisse et y en ordonnÃ©e
# - l'option typ = "l" Ã  l'intÃ©rieur de la commande plot permet de faire un tracÃ© avec une ligne (sinon c'est des points par dÃ©faut)
# - l'option typ = "b" trace ligne ET points
# - lines(x,y) rajoute le tracÃ© de y en fonction de x sur un graphe existant (en ligne)
# - points(x,y) idem mais avec des points



########## PremiÃ¨re partie ######################
####   Detection tendance et/ou saisonnalitÃ© ####
#################################################

# Chargement de la sÃ©rie fmsales
fms = read.table("./sales.txt", header=  T)
# L'option header = T (true) signifie qu'il y a des en-tÃªtes
# pour les noms de colonne dans le fichier txt

# Inspection du dÃ©but de la sÃ©rie
head(fms)
# Cela vous donne les 6 premiÃ¨res valeurs de la sÃ©rie.

# Question : Comment s'appele la colonne qui contient les valeurs de la sÃ©rie ?
		Sales

# Taille de la sÃ©rie
dim(fms)
# Cette commande renvoie deux valeurs : le nombre de lignes
# et le nombre de colonnes de fms.

# Question : Combien de points comportent la sÃ©rie fms ?
	44

# Pour accÃ©der aux valeurs de fms, il faut utiliser le $ et indiquer le nom
# de la colonne qui contient les valeurs de la sÃ©rie : Sales
fms$Sales
# Cette commande renvoie un vecteur qui contient tous les points de la sÃ©rie

# Pour accÃ©der Ã  un point en particulier, il faut utiliser les [] et indiquer l'
# indice du point qui nous intÃ©resse.
# Par exemple, pour rÃ©cupÃ©rer le 5Ã¨me point de la sÃ©rie, on Ã©crit : 
fms$Sales[5]

# Affichage de la sÃ©rie avec la commande plot
plot(fms$Sales, typ = "b")

# Aide sur la cmmande plot.
help(plot)
# Question : 
#En regardant l'aide sur la commande plot, tracer un nouveau 
# graphique avec comme titre de l'axe X "Semaines" et de Y "Ventes".
# Modifier Ã©galement la valeur du paramÃ¨tre type pour qu'on voit
# les points et une ligne continue qui passe par tous les points

# Question :
# En regardant le graphe de la sÃ©rie, pensez-vous qu'il y ait une tendance
# et/ou une saisonnalitÃ©?
non pas de tendance ,non plus une saison

# La commande acf permet d'afficher le corrÃ©logramme de la sÃ©rie:
acf(fms, lag.max = 40)
# Question : 
# A la lecture de ce corrÃ©logramme, la sÃ©rie fms comporte t'elle 
# une tendance ? une saisonnalitÃ© ?
 non pas de tendance ,non plus une saison

# Questions: 
# Charger les deux autres sÃ©ries (tempdub et CO2)
tempdub = read.table... # Ã  complÃ©ter
CO2 = read.table... # Ã  complÃ©ter

# Quelddim(le est la longueur de tempdub = 144  ? de CO2 =300 ?
# Regarder le nom de la colonne qui contient les valeurs
# pour chaque sÃ©rie, vous en aurez besoin ensuite
# Afficher ces deux sÃ©ries sur deux graphes diffÃ©rents
# Aide: la commande dev.new() permet d'ouvrir une nouvelle 
# fenetre pour tracer un graphique

# Question :
# Pour ces deux nouvelles sÃ©ries, tracer le corrÃ©logramme 
# et indiquer si elles compoortent une tendance et/ou 
# une saisonnalitÃ© (de quelle pÃ©riode?).
temp : saison
co2 : saison avec p=12 et tendance

# Pour les sÃ©ries dont vous avez soupconnÃ© une saisonnalitÃ©, on va 
# essayer de confirmer cela avec l'analyse de variance.
# La fonction analyse_variance qui vous est fournie dans le
# fichier fonctions_tp1_st.R va vous aider pour faire Ã§a.
# Elle prend deux paramÃ¨tres en entrÃ©e:
#  1. une sÃ©rie temporelle (tempdub$Temp par exemple)
#  2. un entier qui correspond Ã  la pÃ©riode de la saisonnalitÃ© que vous
# soupÃ§onnez
# Elle renvoie un vecteur contenant 2 valeurs : 
# 1. V_I / V_R (cf slide de cours numÃ©ros 36-40 )
# 2. V_P / V_R (--------------------------------)

source(file="partie1/fonctions_tp1_st.R",encoding="UTF-8")

# Question : appliquer la fonction analyse_variance Ã  la sÃ©rie tempdub
# avec la pÃ©riode de saisonnalitÃ© que vous avez estimÃ©.
# Quelles sont les valeurs renvoyÃ©es par cette fonction ? 
 409.510369   1.129906

# Il vous faut maintenant les comparer aux quantiles de la loi de Fischer
# La commande qf(0.95, v1,v2) donne le quantile 
# de Fisher Ã  (v1,v2) degrÃ¨s de libertÃ© avec confiance de 95%

# Question : Que donne l'analyse de variance pour tempdub ?
# Et pour CO2

--->Ananlyse de la variance pour Temp
qf(0.95, 11,143*11) == 1.794724
fisher(11,143*11) : 1.794724
ona 409 > 1.7 donc il ya presence d'une saison pour Temp 

---> Analyse de la variance pour Co2
	analyse_variance(co2$CO2,12)  :1033.094 9822.024
	qf(0.95, 11,299*11) : 1.791553

Test pour la saisonnalité : on VI/VR =1033.094 >>>> 1.179 donc  il y'a pesence d'une saaison

Test pour la tendance :  VP/VR = 9822.024 
qf(0.95, 299,299*11) : 1.145592

on a Vp/VR >>>> a la valeur de fisher 1.14



########## DeuxiÃ¨me partie ######################
####   PrÃ©diction de sÃ©ries sans tendance    ####
##########   ni saisonnalitÃ©       ##############
#################################################


#Vous allez appliquer dans cette section les mÃ©thodes 
#vues en cours pour faire de la prÃ©diction sans tendance ni saisonnalitÃ©, câ€™est Ã  dire :
# â€” prÃ©vision par la moyenne de toutes les valeurs passÃ©es
# â€” prÃ©vision par la moyenne mobile des k derniÃ¨res valeurs
# â€” prÃ©vision par lissage exponentiel simple
# On testera ces mÃ©thodes sur une nouvelle sÃ©rie LakeHuron qui ne comporte ni
# tendance ni saisonnalitÃ©


# Questions :
# Charger la sÃ©rie LakeHuron qui est dans le fichier huron.txt
""" # Ã  complÃ©ter
# Afficher la sÃ©rie sur un graphique
# VÃ©rifier Ã  l'aide du corrÃ©logramme qu'elle ne comporte ni tendance ni saison



###### 1Ã¨re mÃ©thode : prÃ©diction par moyenne de tout le passÃ© : 

# Si v est un vecteur contenant des valeurs numÃ©riques, la commande mean(v)
# permet de calculer la moyenne de tous les Ã©lÃ©ments du vecteur v.

# Question : 
# En appliquant cette commande Ã  toute la sÃ©rie huron,
# quelle est la prÃ©diciton que vous faites pour la prochaine valeur de cette sÃ©rie par cette 
# 1Ã¨re mÃ©thode ?
# Conservez cette valeur (sur une feuille, ou dans une variable)
	moyen1 = 578.6526
# On va maintenant afficher sur un mÃªme graphique la sÃ©rie huron, ainsi que la prÃ©diction que 
# vous venez de faire pour se prochaine valeur. Pour cela, 
#   1) faire un plot(...) de la huron, en indiquant le nouveau range de l'axe des x par l'option 
#   xlim = c(debut, fin) dans la commande plot. Ici dÃ©but vaut 1, et fin doit valoir la longueur de la
#   sÃ©rie huron + 1 (prÃ©diction de la prochaine valeur Ã  al suite de la sÃ©rie)
#   2) ajouter la prÃ©diction sur le graphe grace Ã  la commande points(x,y, col = "???"), oÃ¹ x est 
#   l'abscisse du point que vous voulez ajouter au graphique (ici l'indice temporel de cette prÃ©diction)
#   et y correspond Ã  la valeur de la prÃ©diction, et Ã  la place des ??? vous pouvez mettre la couleur
#   que vous souhaitez (en anglais, par ex blue, red, green, ou cherchez sur google d'autres couleurs
#   dispos dans R, sans y passer une heure!)


 plot(huron$Niveau, typ = "l",xlab="MOIS",ylab="Niveau",xlim=c(1,length(huron$Niveau)+1))
> points(83,578.6526, col = "blue")

#   Si vous voulez relier le dernier point de la sÃ©rie avec la prÃ©diction, il faut utiliser la
#   commande lines(c(x1,x2), c(y1,y2), col = "???), avec x1 l'indice temporel du dernier point de huron, x2 l'indice
#   temporel de la prÃ©diction (x1+1), y1 la valeur du dernier point de la sÃ©rie, y2 la valeur de la
#   prÃ©diction.
 lines(c(82,83),c(579.96,578.6526) ,col="blue")

 Essayez
#   Vous pourrez ajouter cette commande pour enjoliver votre graphe :
#   legend("bottomleft", c("Historique", "PrÃ©diction par moyenne"), col = c("black", "???"), lty = c(1,1))



# Pour Ã©valuer si cette mÃ©thode de prÃ©diction est bonne, il faut prÃ©dire des valeurs que l'on connaÃ®t
# dÃ©jÃ  (sans les utiliser pour le modÃ¨le) et calculer une erreur quadratique (EQ).
# Par exemple, on peut prÃ©dire le dernier point de la sÃ©rie huron, en faisant comme si on ne
# ne le connaissait pas, et comparer cette prÃ©diction avec la vraie valeur de ce point.
# Question :
# Que vaut la prÃ©diction du dernier point de la sÃ©rie Huron par la mÃ©thode de moyenne sur toutes valeurs
# passÃ©es (attention, on ne doit pas utiliser le dernier point de la sÃ©rie) ?
prediction = ... # Ã  complÃ©ter
hur
# Pour Ã©valuer si cette prÃ©diction est bonne, on va calculer l'EQ entre la vÃ©ritÃ© (dernier point
# de la sÃ©rie) et la prÃ©diction que vous venez de faire (dans prediction).
# 1. on fait la diffÃ©rence entre la vÃ©ritÃ© et la prediction. C'est l'erreur de prÃ©diction

 moyen12=mean(huron$Niveau[0 :81])
eqm=moyen12-huron$Niveau[81]=-1.25358

d = ??? - prediction # Ã  complÃ©ter
d= -1.25358

# 2. On met au carrÃ© cette erreur. Ca donne l'erreur quadratique
d = d^2= 1.571463

# Pour avoir une estimation plus fiable de la performance de cette premiÃ¨re mÃ©thode de prÃ©diction sur
# la sÃ©rie Huron, il faudrait calculer plusieurs erreurs quadratiques et en faire une moyenne.
# Pour l'instant, on a prÃ©dit le dernier point de Huron en utilisant tous les prÃ©cÃ©dents.
# On peut Ã©galement :
#   - prÃ©dire l'avant dernier en utilisant tous ses prÃ©cÃ©dents, et calculer une EQ
#   - prÃ©dire l'avant avant dernier , en utilisant tous ses prÃ©cÃ©dents, et calculer une EQ
#   - etc etc
# Globalement, pour une sÃ©rie S = s1, s2, ..., sL de longueur L, on peut calculer :
#   - p2 la prÃ©diction de s2 en utilisant s1, et calculer e1 l'EQ associÃ©e
#   - p3 la prÃ©diction de s3 en utilisant s1 et s2, et calculer e2 l'EQ associÃ©e
#   - p4 la prÃ©diction de s4 en utilisant s1 s2 et s3, et calculer e3 l'EQ associÃ©e
#   - ....
#   - pL la prÃ©diction de sL en utilisant s1 s2, ... sL-1, et calculer eL-1 l'EQ associÃ©e
# On peut donc faire L-1 prÃ©dictions et calculer L-1 erreurs quadratiques.
# Ces L-1 EQ nous permettent de calculer une erreur quadratique moyenne (EQM)
# associÃ©es Ã  ces erreurs. C'est simplement la moyenne de e1, e2, ..., eL-1
# Cette EQM est une estimation plus robuste de la performance d'une mÃ©thode de prÃ©diction
# sur une sÃ©rie.

# Question
# C'est ce que je vous demande de rÃ©aliser maintenant. Pour cela, je vous conseille d'Ã©crire
# des fonctions intermÃ©diaires qui vont faciliter la comprÃ©hension.
# Regardez la fonction analyse_variance du fichier fonctions_tp1_st.R pour comprendre
# la syntaxe de l'Ã©criture d'une fonction en R (nom de la fonction, paramÃ¨tres, return)
#   1) Ecrire (dans le fichier fonctions_tp1_st.R) une fonction prediction_moyenne(s, i) qui calcule la 
#   prÃ©diction (par moyenne de tout le passÃ©) de la i Ã¨me valeur d une sÃ©rie s en utilsant 
#   les i-1 premiÃ¨res uniquement (c'est Ã  dire le pi ci-dessus)

 prediction_moyenne=function(s, i){
 j=i-1
 m= mean(s[0 : j])
 return (c(m))
 }



#   2) Testez cette fonction : 
#     - d'abord recompiler le fichier fonctions_tp1_st.R : source("./fonctions_tp1_st.R")
#     - puis tester la fonction ici mÃªme en donnant comme paramÃ¨tres votre sÃ©rie huron, et un indice 
#     i au choix. Vous pouvez par exemple, essayer pour i le dernier indice temporel et vÃ©rifier 
#     que le rÃ©sultat est bien celui obtenu plus haut.
#  
hurron = read.table("./huron.txt", header=  T)
prediction_moyenne(huron$Niveau,82)
578.6364

 3) Cette fonction vous permet de calculer simplement les L-1 prÃ©dictions Ã©voquÃ©es ci-dessus 
#      (p2, p3, ..., pL,  il faut faire varier le paramÃ¨tre i de 2 Ã  L). 
#      La commande sapply() permet de faire Ã§a facilement:
#      par exemple:

sapply(c(1:3), function(x){x^2}) # permet d'appliquer la fonction x^2 pour tous les Ã©lÃ©ments du vecteur

# 1:3 (c'est Ã  dire 1,2,3)
#      Utiliser sapply pour calculer un vecteur de longueur L-1 (oÃ¹ L est la longueur de la sÃ©rie Huron)
#      et qui comportent les L-1 prÃ©dictions dont on a besoin : p2, p3, ...., pL
#   
source("./fonctions_tp1_st.R")
prediction=sapply(c(2:82), function(x){
	prediction_moyenne(huron$Niveau,x)
})

4) Ecrire une fonction eqm (prediction, verite) qui prend en paramÃ¨tre un vecteur
#      qui contient des prÃ©dictions et un vecteur verite qui contient les vraies valeurs associÃ©es Ã  
#      ces prÃ©dictions et qui calcule l
'EQM de toutes ces prÃ©dictions.
#      Aidez vous du calcul de l'EQ fait juste au dessus pour calculer toutes les EQ (dans un vecteur) entre verite et prediciton
#      puis utiliser la commande mean() appliquÃ©e Ã  ce vecteur d'EQ

eqm =function(prediction, verite){
	res=(1:length(prediction))
	
	for( i in 1:length(prediction))
      {
	 res[i] =(verite[i] - prediction[i])^2;
	}
	
	 m=mean(res)
	 return (m)
 
 }





#   5) Appliquer cette fonction Ã  la sÃ©rie Huron pour Ã©valuer la performance de 
#     cette 1Ã¨re mÃ©thode de prÃ©diction.
#     Aide :  - la fonction de la question 3) vous permet d'avoir le vecteur contenant les L-1 prÃ©dictions
#             - ensuite, il faut que vous rÃ©cupÃ©riez les L-1 "vÃ©ritÃ©s" qui sont dans la sÃ©rie Huron (attention aux indices correspondants)
#             - ensuite appliquer la fonction eqm Ã  ces 2 vecteurs

eqmMethod1=eqm (prediction,hurron$Niveau[1:81]) 
 1.187299
#1.28 valeur correct
# Gardez bien en mÃ©moire (sur un papier, ou dans votre tÃªte ou dans une variable) cette valeur. Elle 
# sera Ã  comparer avec les performances des autres mÃ©thodes de prÃ©diction.

# Vous pouvez tracer sur un mÃªme graphe la sÃ©rie ainsi que toutes les prÃ©dictions intermÃ©diaires que vous venez de calculer
# (attention aux abscisses des prÃ©dictions)

plot(huron$Niveau, typ = "b")
sapply(c(1:82), function(x){points(prediction, col="blue")})


###### 2Ã¨me mÃ©thode : prÃ©diction par moyenne des k derniÃ¨res valeurs

# Cette mÃ©thode comme son nom l'indique, calcule la moyenne des k derniÃ¨res valeurs de la sÃ©rie pour
# prÃ©dire la prochaine valeur.

k = 5 # on commence par tester cette valeur de k. Vous changerez ensuite

# Question : 
#   - Ecrire une ligne de commande qui permet de rÃ©cupÃ©rer les k derniÃ¨res valeurs de la sÃ©rie huron
#     Aide : l'indice de la derniÃ¨re valeur de la sÃ©rie est length(huron$Niveau). Il faut donc aller rÃ©cupÃ©rer les
#     k prÃ©cÃ©dentes (en comptant celle-lÃ ). Rappel : Si v est un vecteur, la commande v[a:b] permet de rÃ©cupÃ©rer les 
#     elÃ©ments d'indice a, a+1, a+2, ...., b

valeurs=huron$Niveau[(length(huron$Niveau)- k) :length( huron$Niveau)]

#   - Calculer la moyenne de ces k derniÃ¨res valeurs. Cette valeur correpond Ã  la prÃ©diction de la prochaine valeur de
#     la sÃ©rie huron.

mean(valeurs)

prediction

#   - En reprenant les commandes utilisÃ©es avec la premiÃ¨re mÃ©thode, tracez sur un mÃªme
#     graphe, la sÃ©rie huron et la prÃ©diction que vous venez de faire pour la prochaine valeur de la sÃ©rie.


#   - Calculer ensuite une nouvelle prÃ©diction pour k = 3 et ajouter sur le graphe (avec une couleur diffÃ©rente)

 

# Question:
#    - Ecrire une fonction prediction_k_valeur(s,i,k) qui calcule la prÃ©diction de la i Ã¨me valeur d'une sÃ©rie
#    s en utilisant les k valeurs prÃ©cÃ©dentes.
#    - Utiliser cette fonction pour calculer la prÃ©diction de la prochaine valeur de la serie huron pour k = 5 
#      et k = 3 et vÃ©rifier que vous obtenez les mÃªmes valeurs qu'Ã  la question prcÃ©dente


 prediction_k_valeur=function(s,i,k)
{
	valeurs=s[(length(s)- k) :i]
	return (mean(valeurs))
}

source("./fonctions_tp1_st.R")

prediction_k_valeur(huron$Niveau,82,5)

# On va maintenant faire une Ã©valuation robuste de la performance de cette mÃ©thode sur la sÃ©rie huron 
# Pour cela, on va faire comme avec la 1Ã¨re mÃ©thode : 
faire des prÃ©dictions pour des points que l'on 
# connait (sans les utiliser) et calculer l'erreur quadratique moyenne de ces prÃ©dictions.
# 





# Question : 
#   - Sachant que cette mÃ©thode nÃ©cessite de connaÃ®tre les k derniers points pour faire une prÃ©diction, 
# combien de prÃ©dictions peut-on faire pour une sÃ©rie de longueur L (sans compter la prÃ©diction de
# la prochaine valeur) ?


#   - A l'aide de la commande sapply(), calculer un vecteur contenant toutes ces prÃ©dictions (pour k=5 par ex)
prediction2=sapply(c(5:82), function(x){
	 prediction_k_valeur(huron$Niveau,x,5)
})

#   - Calculer l'EQM de ces prÃ©dictions (en utilisant la fonction eqm que vous avez dÃ©jÃ )

eqmMethod2=eqm (prediction2,huron$Niveau[5:82])
1.149253
#0.72
#   - En utilisant les commandes de ces 3 derniers points, Ã©crire une fonction eval_k_valeur(s,k) qui 
#   calcule l'EQM de cette mÃ©thode sur une sÃ©rie s pour une valeur de k en paramÃ¨tre

# a corriger on commence par k+1

eval_k_valeur = function(s,k){

prediction=sapply(c(k:length(s)), function(i){
	 prediction_k_valeur(s,i,k)})

valEqm= eqm (prediction,s[k:length(s)])

return (valEqm)

}

eval_k_valeur(hurron$Niveau,5)

# Vous pouvez tracer sur un mÃªme graphe la sÃ©rie ainsi que toutes les prÃ©dictions intermÃ©diaires que vous venez de calculer
# (attention aux abscisses des prÃ©dictions)

# Question
#  - Appliquer cette mÃ©thode Ã  la sÃ©rie huron pour diffÃ©rentes valeurs de k (2, 3, 5, 10, etc) et choisir la valeur de 
pre=sapply(c(2,3,5,10,11,12), function(x){
	 eval_k_valeur(hurron$Niveau,x)})


# k qui est la meilleure pour cette sÃ©rie. Quelle est la prÃ©diction faite par cette mÃ©thode pour la prochaine valeur de huron ?

min(pre) => k=2

#  - Quelle mÃ©thode (moyenne de tout le passsÃ© ou k derniÃ¨res valeurs) est plus adaptÃ©e Ã  cette sÃ©rie huron ?

methode moyenne des  k valuer precedent avec k=2
 

###### 3Ã¨me mÃ©thode : lissage exponentiel simple (LES)

# Le LES est trÃ¨s facile d'utilisation avec R, il faut utiliser la commande HoltWinters de la faÃ§on suivante:
les = HoltWinters(huron$Niveau, alpha = 0.5, beta = F, gamma = F)
# Il faut donner comme paramÃ¨tres : 
# - 1 sÃ©rie temporelle (ici c'est huron$Niveau)
# - une valeur pour le paramÃ¨tre alpha du LES (ici on met 0.5, on le changera plus tard)
# - puis beta = F (comme false), et gamma = F (comme false), car on n'en a pas besoin en LES

les = HoltWinters(huron$Niveau, alpha = 0.5, beta = F, gamma = F)

# Question : 
# Afficher le modÃ¨le obtenu, en tapant les (le nom de la variable qui stocke le modÃ¨le) 
# Vous devez voir que la valeur de alpha est bien 0.5, que beta et gamma ne sont pas utilisÃ©s.
# Vous devez Ã©galement avoir une autre valeur appelÃ©e "Coefficients".
# Cette valeur est Ã©gale Ã  579.735

# Elle correspond Ã  la derniÃ¨re valeur de ^x_t (x_t chapeau)  que l'on calcule en suivant
# le procedÃ© du LES, ici c'est ^x_83 car il y a 82 valeurs dans la sÃ©rie
# On peut rÃ©cupÃ©rer cette valeur en tapant

les$coefficients

# Question : 
# Sachant que R initialise ^x_1 Ã  la premiÃ¨re valeur de la sÃ©rie (ici, c'est 579.14), 

# calculer (en regardant la formule du cours), les deux prochaines valeurs prÃ©dites ^x_2 et ^x_3

# Vous pourrez retrouver ces valeurs intermÃ©diaires de ^x_t, c'est Ã  dire ^x_2, ^x_3, ...,^x_82 par la commande

les$fitted

# dans la premiÃ¨re colonne (xhat qui veut dire x chapeau)

# VÃ©rifier que vos calculs ont bien donnÃ© les bonnes valeurs pour ^x_2 et ^x_3

# Vous pouvez tracer sur un mÃªme graphe la sÃ©rie ainsi que toutes ces prÃ©dictions intermÃ©diaires 

plot(huron$Niveau, typ = "b")
sapply(c(1:82), function(x){points(x,les$fitted[x], col="blue")})

# (attention aux abscisses des prÃ©dictions)

# Question:

# Calculer l'EQM des 81 prÃ©dictions faites par le LES 

eqm3=eqm(les$fitted[,1],huron$Niveau[2:82]) 
0.7647434

# Question:

# Essayer maintenant de refaire le LES avec une autre valeur de alpha (comme vous voulez), et noter l'EQM
# correspondant

# Pour trouver la valeur d'alpha la plus adaptÃ©e Ã  la sÃ©rie, il faudrait essayer pleins de valeurs de alpha (entre 0 et 1)
# et choisir celle qui conduit Ã  l'EQM la plus faible.
# Vous avez de la chance, la commande HoltWinters peut le faire Ã  votre place.
# Il suffit de ne pas indiquer de valeurs de alpha, et il va chercher tout seul la meilleure !
les_best = HoltWinters(huron$Niveau, beta = F, gamma = F)

# Question:
# Quelle est la valeur de alpha choisie sur ces donnÃ©es ?
 0.9999339

# Quelle est l'EQM associÃ©e ? Normalement, cette EQM doit Ãªtre plus faible que les deux que vous avez 

eqm4=eqm(les_best$fitted[,1],huron$Niveau[2:82])
 0.5846399

# essayÃ©es avant

# Vous pouvez maintenant prÃ©dire la prochaine valeur de la sÃ©rie:
predict(les_best, n.ahead = 1) # n.ahead permet de dire combien de prochains points on souhaite prÃ©dire. 

# Question:
# Afficher sur un mÃªme graphe:
# - la sÃ©rie
# - les prÃ©dictions ^x2, ^x3, ..., ^x82 en bleu
# - la prÃ©diction de la prochaine valeur de la sÃ©rie en rouge

prochaineValeur=predict(les_best, n.ahead = 1)

plot(huron$Niveau, typ = "b")

sapply(c(1:82), function(x){points(x,les_best$fitted[x], col="blue")})

points(83,prochaineValeur, col="red")


#### Conclusion : Choix du meilleur modÃ¨le pour prÃ©dire la sÃ©rie huron


# Parmi toutes les mÃ©thodes que vous avez essayÃ©es, quelle est celle qui conduit Ã  la plus petite EQM ?
les avec alpha =0.09

# Quelle est donc la prÃ©diction que vous faites pour la prochaine valeur de cette sÃ©rie ?


prochaineValeur=predict(les_best, n.ahead = 1)
579.96# meme valeur que celle avant


